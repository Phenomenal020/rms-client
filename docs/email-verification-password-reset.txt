================================================================================
                    EMAIL VERIFICATION & PASSWORD RESET DOCUMENTATION
                    RMS (Result Management System)
                    Better Auth + Resend + Next.js
================================================================================

This document provides a comprehensive guide for implementing email verification,
password reset, and forgot password functionality using Better Auth, Resend email
service, and Next.js.

================================================================================
                            TABLE OF CONTENTS
================================================================================

1. Overview & Architecture
2. Email Service Setup (Resend)
3. Domain Configuration
4. Email Verification Implementation
5. Forgot Password Implementation
6. Reset Password Implementation
7. Security Hooks & Validation
8. Components Breakdown
9. Environment Variables
10. Testing & Troubleshooting
11. Alternatives & Recommendations
12. Best Practices

================================================================================
                        1. OVERVIEW & ARCHITECTURE
================================================================================

The email verification and password reset system consists of:

┌─────────────┐     ┌──────────────┐     ┌─────────────┐     ┌──────────┐
│   User      │────►│  Next.js     │────►│ Better Auth │────►│ Resend   │
│  Action     │     │  Component   │     │   API       │     │  Email   │
└─────────────┘     └──────────────┘     └─────────────┘     └──────────┘
        │                    │                    │                  │
        │                    │                    │                  │
        └────────────────────┴────────────────────┴──────────────────┘
                        Email sent to user

FLOW OVERVIEW:
- User triggers action (sign-up, forgot password, etc.)
- Better Auth generates secure token/URL
- Custom email function (email.ts) sends email via Resend
- User clicks link in email
- Better Auth validates token and processes request
- User redirected to appropriate page

KEY TECHNOLOGIES:
- Better Auth: Authentication library with built-in email flows
- Resend: Modern email API service
- Next.js: React framework for UI components
- Zod: Schema validation for security
- Prisma: Database ORM for storing verification tokens

================================================================================
                    2. EMAIL SERVICE SETUP (RESEND)
================================================================================

2.1 WHAT IS RESEND?
-------------------

Resend is a developer-friendly email API service that provides:
- Simple REST API for sending emails
- High deliverability rates
- Built-in analytics
- Support for custom domains
- Free tier: 3,000 emails/month, 100 emails/day
- Paid plans: Starting at $20/month for 50,000 emails

WHY RESEND?
- Easy integration with Node.js/TypeScript
- Better deliverability than SMTP
- Modern API design
- Good documentation
- Free tier for development

2.2 CREATE RESEND ACCOUNT
--------------------------

1. Visit https://resend.com
2. Sign up for a free account
3. Verify your email address
4. Navigate to API Keys section
5. Create a new API key
6. Copy the API key (starts with "re_")

IMPORTANT:
- Keep your API key secure
- Never commit it to version control
- Use different keys for development and production
- Rotate keys periodically

2.3 INSTALL RESEND PACKAGE
---------------------------

```bash
npm install resend
```

This installs the Resend SDK for Node.js/TypeScript.

2.4 ADD API KEY TO ENVIRONMENT VARIABLES
-----------------------------------------

Add to your `.env` file:

```env
RESEND_API_KEY="re_your_api_key_here"
```

SECURITY NOTES:
- Add `.env` to `.gitignore` (if not already)
- Use `.env.example` as a template without the actual key
- In production, use environment variables from your hosting provider

================================================================================
                        3. DOMAIN CONFIGURATION
================================================================================

3.1 WHY USE A CUSTOM DOMAIN?
-----------------------------

Using a custom domain for sending emails provides:
- Better deliverability (emails less likely to go to spam)
- Professional appearance (emails from your domain)
- Brand consistency
- Higher trust from email providers
- Better sender reputation

WITHOUT CUSTOM DOMAIN:
- Emails sent from Resend's default domain
- May have lower deliverability
- Less professional appearance
- Still functional for development

3.2 PURCHASING A DOMAIN
-----------------------

OPTION 1: NAMECHEAP (RECOMMENDED)
----------------------------------

1. Visit https://www.namecheap.com
2. Search for your desired domain name
3. Add to cart and complete purchase
4. Domain typically costs $10-15/year for .com domains
5. Complete domain registration

POPULAR DOMAIN REGISTRARS:
- Namecheap: Good prices, easy interface
- Hostinger: Affordable, includes hosting
- Google Domains: Simple, integrated with Google services
- Cloudflare: At-cost pricing, excellent DNS management

OPTION 2: HOSTINGER
-------------------

1. Visit https://www.hostinger.com
2. Search for domain name
3. Purchase domain (often includes hosting)
4. Complete registration process

3.3 CONFIGURING DOMAIN IN RESEND
--------------------------------

STEP 1: ADD DOMAIN TO RESEND
-----------------------------

1. Log in to Resend dashboard
2. Navigate to "Domains" section
3. Click "Add Domain"
4. Enter your domain (e.g., "teachersaid.tech")
5. Click "Add"

STEP 2: VERIFY DOMAIN OWNERSHIP
--------------------------------

Resend will provide DNS records to add:

TXT RECORD (Domain Verification):
```
Name: @
Value: [provided by Resend]
TTL: 3600
```

Add this record in your domain's DNS settings:
- Namecheap: Domain List → Manage → Advanced DNS
- Hostinger: DNS Zone Editor
- Cloudflare: DNS → Add Record

STEP 3: ADD SPF RECORD
----------------------

SPF (Sender Policy Framework) prevents email spoofing:

```
Type: TXT
Name: @
Value: v=spf1 include:resend.com ~all
TTL: 3600
```

STEP 4: ADD DKIM RECORDS
------------------------

DKIM (DomainKeys Identified Mail) authenticates emails:

Resend provides 3 CNAME records:
```
Type: CNAME
Name: [provided by Resend]
Value: [provided by Resend]
TTL: 3600
```

Add all 3 CNAME records to your DNS.

STEP 5: ADD DMARC RECORD (OPTIONAL BUT RECOMMENDED)
---------------------------------------------------

DMARC (Domain-based Message Authentication) provides additional security:

```
Type: TXT
Name: _dmarc
Value: v=DMARC1; p=none; rua=mailto:your-email@yourdomain.com
TTL: 3600
```

STEP 6: VERIFY DNS RECORDS
--------------------------

1. Wait 5-10 minutes for DNS propagation
2. Click "Verify" in Resend dashboard
3. Resend checks all DNS records
4. Once verified, domain status changes to "Verified"

VERIFICATION TIME:
- Usually takes 5-30 minutes
- Can take up to 48 hours in rare cases
- Check DNS propagation: https://dnschecker.org

3.4 USING VERIFIED DOMAIN
-------------------------

Once verified, update your email.ts file:

```typescript
from: "email-verification@yourdomain.com"  // Use your verified domain
```

You can use any subdomain or email prefix:
- verification@yourdomain.com
- noreply@yourdomain.com
- support@yourdomain.com
- etc.

================================================================================
                    4. EMAIL VERIFICATION IMPLEMENTATION
================================================================================

4.1 OVERVIEW
------------

Email verification ensures users have access to the email address they
registered with. This prevents:
- Fake email addresses
- Typos in email addresses
- Unauthorized account creation

FLOW:
1. User signs up
2. Account created with emailVerified: false
3. Verification email sent automatically
4. User clicks link in email
5. Better Auth validates token
6. emailVerified set to true
7. User auto-signed in (if configured)

4.2 CONFIGURING EMAIL.TS FILE
------------------------------

Location: src/lib/email.ts

```typescript
import { Resend } from "resend";

interface SendEmailParams {
    to: string;
    subject: string;
    text: string;
}

export async function sendEmail({to, subject, text}: SendEmailParams) {
    const resend = new Resend(process.env.RESEND_API_KEY);

    try {
        const response = await resend.emails.send({
            from: "email-verification@teachersaid.tech",  // Your verified domain
            to: to, 
            subject: subject,
            text: text,
        });

        return response;
    } catch (error) {
        console.error("Email sending error:", error);
        throw error;
    }
}
```

KEY COMPONENTS:
- Resend instance: Created with API key from environment
- from: Must be from verified domain (or Resend default for dev)
- to: Recipient email address
- subject: Email subject line
- text: Plain text email body (can also use HTML)

ENHANCED VERSION WITH HTML:
```typescript
export async function sendEmail({to, subject, text, html}: SendEmailParams) {
    const resend = new Resend(process.env.RESEND_API_KEY);

    try {
        const response = await resend.emails.send({
            from: "email-verification@teachersaid.tech",
            to: to, 
            subject: subject,
            text: text,  // Plain text fallback
            html: html,  // HTML version (optional)
        });

        return response;
    } catch (error) {
        console.error("Email sending error:", error);
        throw error;
    }
}
```

4.3 CONFIGURING AUTH.TS FOR EMAIL VERIFICATION
-----------------------------------------------

Location: src/lib/auth.ts

Add emailVerification configuration to your Better Auth instance:

```typescript
import { sendEmail } from "./email";

export const auth = betterAuth({
  // ... other config
  emailVerification: {
    sendOnSignUp: true,  // Automatically send verification email on sign-up
    autoSignInAfterVerification: true,  // Auto sign-in after email verification
    sendVerificationEmail: async ({ user, url }) => {
      await sendEmail({
        to: user.email,
        subject: "Verify your email",
        text: `Click here to verify your email: ${url}`,
      });
    },
  },
});
```

CONFIGURATION OPTIONS:
- sendOnSignUp: Boolean - Send email automatically when user signs up
- autoSignInAfterVerification: Boolean - Sign user in after they verify
- sendVerificationEmail: Function - Custom function to send the email
  - Receives: { user, url }
  - user: User object with email, name, etc.
  - url: Verification link with token (generated by Better Auth)

CUSTOMIZING THE EMAIL:
```typescript
sendVerificationEmail: async ({ user, url }) => {
  await sendEmail({
    to: user.email,
    subject: "Welcome! Please verify your email",
    text: `
      Hi ${user.name},
      
      Thank you for signing up! Please verify your email address by clicking
      the link below:
      
      ${url}
      
      This link will expire in 24 hours.
      
      If you didn't create this account, please ignore this email.
    `,
  });
},
```

4.4 VERIFY EMAIL PAGE COMPONENT
--------------------------------

Location: app/(auth)/verify-email/page.jsx

```typescript
import { getServerSession } from "@/src/lib/get-session";
import { redirect, unauthorized } from "next/navigation";
import { ResendVerificationButton } from "./resend-verification-button";

export const metadata = {
  title: "Verify Email",
};

export default async function VerifyEmailPage() {
  const session = await getServerSession();
  const user = session?.user;

  // Redirect if not logged in
  if (!user) unauthorized();

  // Redirect if already verified
  if (user.emailVerified) redirect("/dashboard");

  return (
    <main className="flex flex-1 items-center justify-center px-4 text-center">
      <div className="space-y-6">
        <div className="space-y-2">
          <h1 className="text-2xl font-semibold">Verify your email</h1>
          <p className="text-muted-foreground">
            A verification email was sent to your inbox.
          </p>
        </div>
        <ResendVerificationButton email={user.email} />
      </div>
    </main>
  );
}
```

KEY FEATURES:
- Server component (async)
- Checks if user is logged in
- Checks if email is already verified
- Displays resend button component
- Redirects appropriately

4.5 RESEND VERIFICATION BUTTON COMPONENT
----------------------------------------

Location: app/(auth)/verify-email/resend-verification-button.jsx

```typescript
"use client";

import { LoadingButton } from "@/shared-components/loading-button";
import { authClient } from "@/src/lib/auth-client";
import { useState } from "react";

export function ResendVerificationButton({ email }) {
  const [isLoading, setIsLoading] = useState(false);
  const [success, setSuccess] = useState(null);
  const [error, setError] = useState(null);

  async function resendVerificationEmail() {
    setSuccess(null);
    setError(null);
    setIsLoading(true);
 
    const { error } = await authClient.sendVerificationEmail({
      email,
      callbackURL: "/email-verified",  // Where to redirect after verification
    });

    setIsLoading(false);

    if (error) {
      setError(error.message || "Something went wrong");
    } else {
      setSuccess("Verification email sent successfully");
    }
  }

  return (
    <div className="space-y-4">
      {success && (
        <div role="status" className="text-sm text-green-600">
          {success}
        </div>
      )}
      {error && (
        <div role="alert" className="text-sm text-red-600">
          {error}
        </div>
      )}

      <LoadingButton
        onClick={resendVerificationEmail} 
        className="w-full"
        loading={isLoading}
      >
        Resend verification email
      </LoadingButton>
    </div>
  );
}
```

KEY FEATURES:
- Client component ("use client")
- Uses authClient.sendVerificationEmail()
- Loading state management
- Success/error message display
- callbackURL: Where user is redirected after clicking email link

4.6 REQUIRING EMAIL VERIFICATION FOR LOGIN
---------------------------------------------

To require email verification before users can sign in:

```typescript
emailAndPassword: {
  enabled: true,
  requireEmailVerification: true,  // Add this line
  // ... other config
},
```

When enabled:
- Users can sign up but cannot sign in until verified
- Sign-in attempts with unverified email will fail
- User must verify email first

4.7 EMAIL VERIFIED CALLBACK PAGE
---------------------------------

Create a page for after email verification:

Location: app/(auth)/email-verified/page.jsx

```typescript
import { getServerSession } from "@/src/lib/get-session";
import { redirect } from "next/navigation";

export default async function EmailVerifiedPage() {
  const session = await getServerSession();
  
  if (!session) {
    redirect("/sign-in");
  }

  return (
    <main className="flex flex-1 items-center justify-center px-4 text-center">
      <div className="space-y-4">
        <h1 className="text-2xl font-semibold">Email Verified!</h1>
        <p className="text-muted-foreground">
          Your email has been successfully verified.
        </p>
        <a href="/dashboard" className="text-primary hover:underline">
          Go to Dashboard
        </a>
      </div>
    </main>
  );
}
```

================================================================================
                    5. FORGOT PASSWORD IMPLEMENTATION
================================================================================

5.1 OVERVIEW
------------

Forgot password allows users to reset their password when they've forgotten it.
This is a critical security feature that prevents account lockouts.

FLOW:
1. User enters email on forgot password page
2. System checks if email exists (without revealing if it exists)
3. If email exists, reset token generated and sent via email
4. User receives email with reset link
5. User clicks link (contains token)
6. User redirected to reset password page
7. User enters new password
8. Token validated and password updated

SECURITY CONSIDERATIONS:
- Never reveal if email exists (prevents email enumeration)
- Tokens expire after set time (typically 1 hour)
- Tokens are single-use
- Rate limiting prevents abuse

5.2 CONFIGURING AUTH.TS FOR FORGOT PASSWORD
--------------------------------------------

Location: src/lib/auth.ts

Add sendResetPassword to emailAndPassword configuration:

```typescript
emailAndPassword: {
  enabled: true,
  async sendResetPassword({ user, url }) {
    await sendEmail({
      to: user.email,
      subject: "Reset your password",
      text: `Click here to reset your password: ${url}`,
    });
  },
},
```

KEY COMPONENTS:
- sendResetPassword: Function called when password reset is requested
- Receives: { user, url }
- user: User object with email, name, etc.
- url: Reset link with token (generated by Better Auth)

CUSTOMIZING THE EMAIL:
```typescript
async sendResetPassword({ user, url }) {
  await sendEmail({
    to: user.email,
    subject: "Password Reset Request",
    text: `
      Hi ${user.name},
      
      You requested to reset your password. Click the link below to reset it:
      
      ${url}
      
      This link will expire in 1 hour.
      
      If you didn't request this, please ignore this email. Your password
      will remain unchanged.
    `,
  });
},
```

5.3 FORGOT PASSWORD PAGE COMPONENT
-----------------------------------

Location: app/(auth)/forgot-password/page.jsx

```typescript
import { ForgotPasswordForm } from "./forgot-password-form";

export const metadata = {
  title: "Forgot password",
};

export default function ForgotPasswordPage() {
  return (
    <main className="flex min-h-svh items-center justify-center px-4">
      <div className="space-y-6 w-full">
        <div className="space-y-2 text-center">
          <h1 className="text-2xl font-semibold">Forgot password</h1>
          <p className="text-muted-foreground">
            Enter your email address and we&apos;ll send you a link to reset
            your password.
          </p>
        </div>
        <ForgotPasswordForm />
      </div>
    </main>
  );
}
```

Simple page wrapper that displays the form component.

5.4 FORGOT PASSWORD FORM COMPONENT
-----------------------------------

Location: app/(auth)/forgot-password/forgot-password-form.jsx

```typescript
"use client";

import { LoadingButton } from "@/shared-components/loading-button";
import { Card, CardContent } from "@/shadcn/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/shadcn/ui/form";
import { Input } from "@/shadcn/ui/input";
import { authClient } from "@/src/lib/auth-client";
import { zodResolver } from "@hookform/resolvers/zod";
import { useState } from "react";
import { useForm } from "react-hook-form";
import { z } from "zod";

const forgotPasswordSchema = z.object({
  email: z.email({ message: "Please enter a valid email" }),
});

export function ForgotPasswordForm() {
  const [success, setSuccess] = useState(null);
  const [error, setError] = useState(null);

  const form = useForm({
    resolver: zodResolver(forgotPasswordSchema),
    defaultValues: { email: "" },
  });

  async function onSubmit({ email }) {
    setSuccess(null);
    setError(null);

    const { error } = await authClient.requestPasswordReset({
      email,
      redirectTo: "/reset-password",  // Where to redirect after clicking link
    });

    if (error) {
      setError(error.message || "Something went wrong");
    } else {
      // Always show success message (prevents email enumeration)
      setSuccess(
        "If an account exists for this email, we've sent a password reset link.",
      );
      form.reset();
    }
  }

  const loading = form.formState.isSubmitting;

  return (
    <Card className="mx-auto w-full max-w-md">
      <CardContent>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="email"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Email</FormLabel>
                  <FormControl>
                    <Input
                      type="email"
                      placeholder="your@email.com"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {success && (
              <div role="status" className="text-sm text-green-600">
                {success}
              </div>
            )}
            {error && (
              <div role="alert" className="text-sm text-red-600">
                {error}
              </div>
            )}

            <LoadingButton type="submit" className="w-full" loading={loading}>
              Send reset link
            </LoadingButton>
          </form>
        </Form>
      </CardContent>
    </Card>
  );
}
```

KEY FEATURES:
- Email validation using Zod
- Uses authClient.requestPasswordReset()
- Always shows success message (security best practice)
- redirectTo: Where user goes after clicking email link
- Form validation and error handling

SECURITY NOTE:
The success message always says "If an account exists..." even if the email
doesn't exist. This prevents attackers from enumerating valid email addresses.

================================================================================
                    6. RESET PASSWORD IMPLEMENTATION
================================================================================

6.1 OVERVIEW
------------

Reset password allows users to set a new password after clicking the link from
the forgot password email. The token in the URL validates the request.

FLOW:
1. User clicks reset link from email (contains token)
2. User redirected to reset password page with token in URL
3. User enters new password
4. Token validated by Better Auth
5. Password updated in database
6. Token invalidated (single-use)
7. User redirected to sign-in page

6.2 RESET PASSWORD PAGE COMPONENT
----------------------------------

Location: app/(auth)/reset-password/page.jsx

```typescript
import { ResetPasswordForm } from "./reset-password-form";

export const metadata = {
  title: "Reset password",
};

export default async function ResetPasswordPage({ searchParams }) {
  const { token } = await searchParams;

  return (
    <main className="flex min-h-svh items-center justify-center px-4">
      {token ? (
        <ResetPasswordUI token={token} />
      ) : (
        <div role="alert" className="text-red-600">
          Token is missing.
        </div>
      )}
    </main>
  );
}

function ResetPasswordUI({ token }) {
  return (
    <div className="w-full space-y-6">
      <div className="space-y-2 text-center">
        <h1 className="text-2xl font-semibold">Reset password</h1>
        <p className="text-muted-foreground">Enter your new password below.</p>
      </div>
      <ResetPasswordForm token={token} />
    </div>
  );
}
```

KEY FEATURES:
- Server component (async)
- Extracts token from URL search params
- Validates token exists before rendering form
- Passes token to form component

6.3 RESET PASSWORD FORM COMPONENT
-----------------------------------

Location: app/(auth)/reset-password/reset-password-form.jsx

```typescript
"use client";

import { LoadingButton } from "@/shared-components/loading-button";
import { PasswordInput } from "@/shared-components/password-input";
import { Card, CardContent } from "@/shadcn/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/shadcn/ui/form";
import { authClient } from "@/src/lib/auth-client";
import { passwordSchema } from "@/src/lib/validation";
import { zodResolver } from "@hookform/resolvers/zod";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { useForm } from "react-hook-form";
import { z } from "zod";

const resetPasswordSchema = z.object({
  newPassword: passwordSchema,
});

export function ResetPasswordForm({ token }) {
  const [success, setSuccess] = useState(null);
  const [error, setError] = useState(null);
  const router = useRouter();

  const form = useForm({
    resolver: zodResolver(resetPasswordSchema),
    defaultValues: { newPassword: "" },
  });

  async function onSubmit({ newPassword }) {
    setSuccess(null);
    setError(null);

    const { error } = await authClient.resetPassword({
      newPassword,
      token,  // Token from URL
    });

    if (error) {
      setError(error.message || "Something went wrong");
    } else {
      setSuccess("Password has been reset. You can now sign in.");
      setTimeout(() => router.push("/sign-in"), 3000);
      form.reset();
    }
  }

  const loading = form.formState.isSubmitting;

  return (
    <Card className="mx-auto w-full max-w-md">
      <CardContent>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="newPassword"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>New password</FormLabel>
                  <FormControl>
                    <PasswordInput
                      autoComplete="new-password"
                      placeholder="Enter new password"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {success && (
              <div role="status" className="text-sm text-green-600">
                {success}
              </div>
            )}
            {error && (
              <div role="alert" className="text-sm text-red-600">
                {error}
              </div>
            )}

            <LoadingButton type="submit" className="w-full" loading={loading}>
              Reset password
            </LoadingButton>
          </form>
        </Form>
      </CardContent>
    </Card>
  );
}
```

KEY FEATURES:
- Password validation using passwordSchema
- Uses authClient.resetPassword() with token
- Success message with auto-redirect
- Error handling
- Token passed from URL to API call

6.4 PASSWORD VALIDATION SCHEMA
-------------------------------

Location: src/lib/validation.js

```javascript
import z from "zod";

export const passwordSchema = z
  .string()
  .min(1, { message: "Password is required" })
  .min(8, { message: "Password must be at least 8 characters" })
  .regex(/[^A-Za-z0-9]/, {
    message: "Password must contain at least one special character",
  });
```

REQUIREMENTS:
- Minimum 8 characters
- At least one special character (non-alphanumeric)
- Used in sign-up, reset password, and change password

================================================================================
                    7. SECURITY HOOKS & VALIDATION
================================================================================

7.1 OVERVIEW
------------

Security hooks allow you to intercept and validate authentication requests
before they're processed. This is crucial for enforcing password policies and
preventing weak passwords.

7.2 IMPLEMENTING PASSWORD VALIDATION HOOK
------------------------------------------

Location: src/lib/auth.ts

Add hooks configuration to your Better Auth instance:

```typescript
import { createAuthMiddleware, APIError } from "better-auth/api";
import { passwordSchema } from "./validation";

export const auth = betterAuth({
  // ... other config
  hooks: {
    before: createAuthMiddleware(async (ctx) => {
      // Validate password on sign-up, reset, and change password
      if (
        ctx.path === "/sign-up/email" ||
        ctx.path === "/reset-password" ||
        ctx.path === "/change-password"
      ) {
        // Type assertion needed because ctx.body is typed as unknown
        const body = ctx.body as { password?: string; newPassword?: string };
        
        // Get password from either field (sign-up uses 'password', reset uses 'newPassword')
        const password = body.password || body.newPassword;
        
        // Validate password using Zod schema
        const { error } = passwordSchema.safeParse(password);
        
        if (error) {
          // Throw API error if validation fails
          throw new APIError("BAD_REQUEST", {
            message: error.message,
          });
        }
      }
    }),
  },
});
```

KEY COMPONENTS:
- hooks.before: Runs before the request is processed
- createAuthMiddleware: Creates middleware function
- ctx.path: The API endpoint being called
- ctx.body: Request body (typed as unknown, needs assertion)
- passwordSchema.safeParse(): Validates password without throwing
- APIError: Better Auth error class for API responses

7.3 WHY TYPE ASSERTION IS NEEDED
----------------------------------

TypeScript types `ctx.body` as `unknown` because:
- Different endpoints have different body shapes
- Better Auth can't know the body type at compile time
- Type assertion tells TypeScript what shape to expect

CORRECT APPROACH:
```typescript
const body = ctx.body as { password?: string; newPassword?: string };
const password = body.password || body.newPassword;
```

This safely handles both:
- Sign-up: Uses `password` field
- Reset/Change: Uses `newPassword` field

7.4 VALIDATION FLOW
--------------------

┌─────────────┐     ┌──────────────┐     ┌─────────────┐     ┌──────────┐
│   Client    │────►│  API Route   │────►│   Hook      │────►│ Better   │
│  Request    │     │  /api/auth   │     │  Validates  │     │   Auth   │
└─────────────┘     └──────────────┘     └─────────────┘     └──────────┘
                                                                    │
                                                                    ▼
                                                              ┌──────────┐
                                                              │ Process  │
                                                              │ Request  │
                                                              └──────────┘

If validation fails:
- APIError thrown
- Request stops
- Error returned to client
- Password not changed/created

7.5 ADDITIONAL SECURITY MEASURES
---------------------------------

RATE LIMITING (RECOMMENDED):
```typescript
// Add rate limiting to prevent abuse
// Consider using a library like 'express-rate-limit' or similar
```

TOKEN EXPIRATION:
- Reset tokens expire after 1 hour (default in Better Auth)
- Verification tokens expire after 24 hours (default)
- Tokens are single-use (invalidated after use)

PASSWORD STRENGTH:
- Enforced via passwordSchema
- Minimum 8 characters
- Special character required
- Can add more requirements (uppercase, numbers, etc.)

7.6 ENHANCED PASSWORD SCHEMA (OPTIONAL)
----------------------------------------

For stronger passwords:

```typescript
export const strongPasswordSchema = z
  .string()
  .min(1, { message: "Password is required" })
  .min(8, { message: "Password must be at least 8 characters" })
  .regex(/[A-Z]/, { message: "Password must contain at least one uppercase letter" })
  .regex(/[a-z]/, { message: "Password must contain at least one lowercase letter" })
  .regex(/[0-9]/, { message: "Password must contain at least one number" })
  .regex(/[^A-Za-z0-9]/, {
    message: "Password must contain at least one special character",
  });
```

7.7 HOOKS FOR OTHER VALIDATIONS
--------------------------------

You can add more validations:

```typescript
hooks: {
  before: createAuthMiddleware(async (ctx) => {
    // Password validation
    if (ctx.path === "/sign-up/email" || ctx.path === "/reset-password") {
      // ... password validation
    }
    
    // Email validation
    if (ctx.path === "/sign-up/email") {
      const body = ctx.body as { email?: string };
      if (body.email && !isValidEmailDomain(body.email)) {
        throw new APIError("BAD_REQUEST", {
          message: "Email domain not allowed",
        });
      }
    }
    
    // Rate limiting check
    if (await isRateLimited(ctx)) {
      throw new APIError("TOO_MANY_REQUESTS", {
        message: "Too many requests. Please try again later.",
      });
    }
  }),
},
```

================================================================================
                        8. COMPONENTS BREAKDOWN
================================================================================

8.1 FILE STRUCTURE
-------------------

```
app/(auth)/
├── verify-email/
│   ├── page.jsx                      # Verify email page (server)
│   └── resend-verification-button.jsx # Resend button (client)
│
├── forgot-password/
│   ├── page.jsx                      # Forgot password page (server)
│   └── forgot-password-form.jsx      # Forgot password form (client)
│
└── reset-password/
    ├── page.jsx                      # Reset password page (server)
    └── reset-password-form.jsx       # Reset password form (client)

src/lib/
├── auth.ts                           # Better Auth config with hooks
├── email.ts                          # Resend email function
└── validation.js                     # Password validation schema
```

8.2 COMPONENT SUMMARY
----------------------

VERIFY EMAIL PAGE (page.jsx):
- Server component
- Checks authentication status
- Checks verification status
- Renders resend button

RESEND VERIFICATION BUTTON (resend-verification-button.jsx):
- Client component
- Calls authClient.sendVerificationEmail()
- Loading and error states
- Success message display

FORGOT PASSWORD PAGE (page.jsx):
- Server component
- Simple wrapper for form

FORGOT PASSWORD FORM (forgot-password-form.jsx):
- Client component
- Email input with validation
- Calls authClient.requestPasswordReset()
- Always shows success (security)

RESET PASSWORD PAGE (page.jsx):
- Server component
- Extracts token from URL
- Validates token exists
- Renders form or error

RESET PASSWORD FORM (reset-password-form.jsx):
- Client component
- New password input
- Password validation
- Calls authClient.resetPassword()
- Auto-redirect on success

8.3 SHARED COMPONENTS USED
---------------------------

- LoadingButton: Button with loading state
- PasswordInput: Password field with show/hide toggle
- Card, CardContent: UI container components
- Form components: FormField, FormLabel, FormMessage, etc.
- All from shadcn/ui or shared-components

================================================================================
                        9. ENVIRONMENT VARIABLES
================================================================================

9.1 REQUIRED VARIABLES
----------------------

Add to your `.env` file:

```env
# Resend API Key
RESEND_API_KEY="re_your_api_key_here"

# Better Auth (if not already set)
BETTER_AUTH_SECRET="your-secret-key-minimum-32-characters"
BETTER_AUTH_URL="http://localhost:3000"

# Database (if not already set)
DATABASE_URL="postgresql://user:password@localhost:5432/database"
```

9.2 PRODUCTION VARIABLES
------------------------

For production, update:

```env
BETTER_AUTH_URL="https://yourdomain.com"
```

And ensure:
- RESEND_API_KEY is set in production environment
- Domain is verified in Resend
- All DNS records are configured
- HTTPS is enabled

9.3 ENVIRONMENT VARIABLE SECURITY
----------------------------------

BEST PRACTICES:
- Never commit `.env` to version control
- Use `.env.example` as template (without actual keys)
- Use different keys for dev/staging/production
- Rotate keys periodically
- Use environment variable management in hosting:
  - Vercel: Environment Variables in dashboard
  - Netlify: Site settings → Environment variables
  - Railway: Variables tab
  - AWS: Parameter Store or Secrets Manager

================================================================================
                    10. TESTING & TROUBLESHOOTING
================================================================================

10.1 TESTING EMAIL VERIFICATION
-------------------------------

STEP 1: TEST SIGN-UP FLOW
--------------------------

1. Navigate to sign-up page
2. Fill in form and submit
3. Check email inbox (and spam folder)
4. Verify email contains link
5. Click link
6. Verify redirect to email-verified page
7. Check database: emailVerified should be true

STEP 2: TEST RESEND FUNCTIONALITY
----------------------------------

1. Navigate to verify-email page (if not verified)
2. Click "Resend verification email"
3. Check email inbox
4. Verify new email received
5. Click link and verify it works

STEP 3: TEST REQUIRE EMAIL VERIFICATION
----------------------------------------

1. Enable requireEmailVerification: true
2. Sign up new user
3. Try to sign in (should fail)
4. Verify email
5. Try to sign in (should succeed)

10.2 TESTING FORGOT PASSWORD
-----------------------------

STEP 1: TEST FORGOT PASSWORD REQUEST
-------------------------------------

1. Navigate to forgot-password page
2. Enter valid email
3. Submit form
4. Check email inbox
5. Verify reset link received
6. Verify success message shown (even for invalid emails)

STEP 2: TEST RESET PASSWORD
----------------------------

1. Click reset link from email
2. Verify redirect to reset-password page with token
3. Enter new password
4. Submit form
5. Verify success message
6. Verify redirect to sign-in
7. Sign in with new password

10.3 TESTING SECURITY HOOKS
----------------------------

STEP 1: TEST WEAK PASSWORD REJECTION
-------------------------------------

1. Try to sign up with password < 8 characters
2. Verify error message shown
3. Try password without special character
4. Verify error message shown
5. Try valid password
6. Verify sign-up succeeds

STEP 2: TEST RESET PASSWORD VALIDATION
---------------------------------------

1. Request password reset
2. Click reset link
3. Try weak password
4. Verify validation error
5. Try valid password
6. Verify reset succeeds

10.4 COMMON ISSUES & SOLUTIONS
-------------------------------

ISSUE: "Email not sending"
---------------------------

CAUSES:
- RESEND_API_KEY not set or incorrect
- Domain not verified (if using custom domain)
- API key rate limit exceeded
- Invalid email address

SOLUTIONS:
- Check .env file has RESEND_API_KEY
- Verify API key in Resend dashboard
- Check domain verification status
- Verify email format
- Check Resend dashboard for errors
- Check console for error messages

ISSUE: "Emails going to spam"
------------------------------

CAUSES:
- Using default Resend domain
- Missing SPF/DKIM records
- Poor email content
- Sending to invalid emails

SOLUTIONS:
- Use verified custom domain
- Add all DNS records (SPF, DKIM, DMARC)
- Use proper email content (not spammy)
- Verify email addresses before sending
- Warm up domain (send gradually)

ISSUE: "Token invalid or expired"
-----------------------------------

CAUSES:
- Token already used (single-use)
- Token expired (default 1 hour)
- Token tampered with
- Wrong token in URL

SOLUTIONS:
- Request new reset link
- Check token hasn't been used
- Verify token in URL is correct
- Check Better Auth token expiration settings

ISSUE: "TypeScript errors with ctx.body"
------------------------------------------

CAUSES:
- ctx.body typed as unknown
- Accessing properties without type assertion

SOLUTIONS:
- Use type assertion: `ctx.body as { password?: string }`
- Check property names match (password vs newPassword)
- Use optional chaining if needed

ISSUE: "Password validation not working"
----------------------------------------

CAUSES:
- Hook not configured correctly
- Wrong path in condition
- Schema not imported
- Validation logic error

SOLUTIONS:
- Verify hook is in hooks.before
- Check ctx.path matches exactly
- Verify passwordSchema imported
- Test schema independently
- Check console for errors

ISSUE: "Domain verification failing"
------------------------------------

CAUSES:
- DNS records not added
- DNS propagation delay
- Wrong record values
- TTL too high

SOLUTIONS:
- Verify all DNS records added
- Wait 5-30 minutes for propagation
- Check records with DNS checker tool
- Verify record values match Resend exactly
- Lower TTL for faster updates

10.5 DEBUGGING TIPS
-------------------

ENABLE DEBUG LOGGING:
```typescript
// In email.ts
console.log("Sending email to:", to);
console.log("Subject:", subject);

// In auth.ts hooks
console.log("Hook triggered for path:", ctx.path);
console.log("Body:", ctx.body);
```

CHECK RESEND DASHBOARD:
- View sent emails
- Check delivery status
- See error messages
- Monitor API usage

CHECK DATABASE:
- Verify tokens in Verification table
- Check user emailVerified status
- Verify sessions created
- Check token expiration times

USE BROWSER DEV TOOLS:
- Network tab: Check API requests
- Console: Check for errors
- Application: Check cookies
- Local Storage: Check for data

================================================================================
                    11. ALTERNATIVES & RECOMMENDATIONS
================================================================================

11.1 EMAIL SERVICE ALTERNATIVES
--------------------------------

RESEND (CURRENT):
- Pros: Modern API, good docs, free tier, easy setup
- Cons: Newer service, smaller community
- Best for: Modern apps, TypeScript projects

SENDGRID:
- Pros: Established, high deliverability, good analytics
- Cons: More complex setup, older API
- Best for: Enterprise, high volume

MAILGUN:
- Pros: Reliable, good for transactional emails
- Cons: Pricing can be higher
- Best for: High-volume transactional

AWS SES:
- Pros: Very cheap, scalable, AWS integration
- Cons: Complex setup, requires AWS account
- Best for: AWS-based infrastructure

POSTMARK:
- Pros: Excellent deliverability, great support
- Cons: More expensive, focused on transactional
- Best for: Critical transactional emails

NODEMAILER (SMTP):
- Pros: Free with Gmail/SMTP, simple
- Cons: Lower deliverability, rate limits
- Best for: Development, low volume

11.2 AUTHENTICATION ALTERNATIVES
---------------------------------

BETTER AUTH (CURRENT):
- Pros: Modern, TypeScript-first, flexible
- Cons: Newer, smaller community
- Best for: Modern Next.js apps

NEXT-AUTH (AUTH.JS):
- Pros: Established, large community, many providers
- Cons: More complex, less type-safe
- Best for: Complex auth requirements

SUPABASE AUTH:
- Pros: Integrated with Supabase, easy setup
- Cons: Vendor lock-in, requires Supabase
- Best for: Supabase-based projects

FIREBASE AUTH:
- Pros: Google-backed, feature-rich
- Cons: Vendor lock-in, pricing can scale
- Best for: Firebase-based projects

CUSTOM IMPLEMENTATION:
- Pros: Full control, no dependencies
- Cons: Security risks, time-consuming
- Best for: Very specific requirements

11.3 PASSWORD VALIDATION ALTERNATIVES
--------------------------------------

ZOD (CURRENT):
- Pros: TypeScript-first, great DX, composable
- Cons: Runtime validation only
- Best for: TypeScript projects

YUP:
- Pros: Mature, feature-rich, good docs
- Cons: Less TypeScript-friendly
- Best for: JavaScript projects

JOI:
- Pros: Very powerful, extensive validation
- Cons: Larger bundle, less TypeScript support
- Best for: Complex validation needs

CLASS-VALIDATOR:
- Pros: Decorator-based, works with TypeScript
- Cons: Requires classes, more setup
- Best for: Class-based architectures

CUSTOM VALIDATION:
- Pros: Full control, lightweight
- Cons: More code to maintain
- Best for: Simple, specific requirements

11.4 RECOMMENDATIONS
--------------------

FOR DEVELOPMENT:
- Use Resend free tier
- Use default Resend domain (no custom domain needed)
- Test with real email addresses
- Use environment variables for all keys

FOR PRODUCTION:
- Use verified custom domain
- Set up all DNS records (SPF, DKIM, DMARC)
- Monitor email delivery rates
- Set up email analytics
- Implement rate limiting
- Use strong password requirements
- Enable email verification requirement
- Monitor for abuse

FOR SCALING:
- Consider email service with higher limits
- Implement email queue for high volume
- Add email templates
- Set up email monitoring/alerts
- Consider email service with better analytics

11.5 COST CONSIDERATIONS
------------------------

RESEND:
- Free: 3,000 emails/month, 100/day
- Pro: $20/month, 50,000 emails
- Enterprise: Custom pricing

SENDGRID:
- Free: 100 emails/day
- Essentials: $19.95/month, 50,000 emails
- Pro: Custom pricing

MAILGUN:
- Foundation: $35/month, 50,000 emails
- Growth: $80/month, 100,000 emails

AWS SES:
- $0.10 per 1,000 emails
- Very cheap for high volume

RECOMMENDATION:
- Start with Resend free tier
- Upgrade when approaching limits
- Consider AWS SES for very high volume
- Factor in deliverability, not just cost

================================================================================
                        12. BEST PRACTICES
================================================================================

12.1 EMAIL BEST PRACTICES
--------------------------

CONTENT:
- Clear, concise subject lines
- Professional tone
- Include your brand/company name
- Provide clear call-to-action
- Include unsubscribe option (if applicable)
- Test email rendering in different clients

TECHNICAL:
- Use verified custom domain
- Set up all DNS records
- Monitor deliverability
- Handle bounces and complaints
- Respect rate limits
- Use proper email headers

SECURITY:
- Never expose API keys
- Use environment variables
- Rotate keys periodically
- Monitor for abuse
- Implement rate limiting
- Validate email addresses

12.2 PASSWORD BEST PRACTICES
------------------------------

REQUIREMENTS:
- Minimum 8 characters (12+ recommended)
- Mix of uppercase, lowercase, numbers, special chars
- No common passwords
- No user information in password
- Enforce on all password operations

STORAGE:
- Never store plain text passwords
- Use secure hashing (Better Auth handles this)
- Salt passwords (Better Auth handles this)
- Never log passwords

USER EXPERIENCE:
- Show password requirements clearly
- Provide strength indicator
- Allow password visibility toggle
- Support password managers
- Provide forgot password option

12.3 SECURITY BEST PRACTICES
-----------------------------

AUTHENTICATION:
- Require email verification
- Enforce strong passwords
- Implement rate limiting
- Use secure tokens (Better Auth handles this)
- Set appropriate token expiration
- Invalidate tokens after use

VALIDATION:
- Validate on both client and server
- Never trust client-side validation alone
- Use type-safe validation (Zod)
- Provide clear error messages
- Don't reveal if email exists (forgot password)

ERROR HANDLING:
- Don't expose sensitive information
- Log errors server-side
- Provide user-friendly messages
- Handle edge cases gracefully
- Monitor for suspicious activity

12.4 CODE ORGANIZATION
-----------------------

STRUCTURE:
- Keep email logic centralized (email.ts)
- Separate validation schemas (validation.js)
- Use consistent error handling
- Document complex logic
- Use TypeScript for type safety

NAMING:
- Use descriptive function names
- Follow consistent naming conventions
- Use clear variable names
- Comment complex logic

TESTING:
- Test all email flows
- Test validation logic
- Test error cases
- Test edge cases
- Use real email addresses for testing

12.5 USER EXPERIENCE
--------------------

FEEDBACK:
- Show loading states
- Provide success messages
- Display clear error messages
- Guide users through process
- Provide helpful instructions

NAVIGATION:
- Clear call-to-action buttons
- Logical page flow
- Easy to find features
- Mobile-friendly design
- Accessible design

COMMUNICATION:
- Clear email content
- Professional appearance
- Timely responses
- Helpful error messages
- Support contact information

================================================================================
                           QUICK REFERENCE
================================================================================

ESSENTIAL FILES:
----------------

src/lib/email.ts              # Resend email function
src/lib/auth.ts               # Better Auth config with hooks
src/lib/validation.js         # Password validation schema
app/(auth)/verify-email/      # Email verification pages
app/(auth)/forgot-password/   # Forgot password pages
app/(auth)/reset-password/    # Reset password pages

ENVIRONMENT VARIABLES:
----------------------

RESEND_API_KEY="re_..."       # Resend API key
BETTER_AUTH_SECRET="..."      # Better Auth secret
BETTER_AUTH_URL="..."         # App URL

KEY FUNCTIONS:
--------------

sendEmail()                   # Send email via Resend
authClient.sendVerificationEmail()  # Resend verification
authClient.requestPasswordReset()   # Request password reset
authClient.resetPassword()           # Reset password

VALIDATION:
-----------

passwordSchema                # Password validation rules
- Min 8 characters
- At least one special character

DNS RECORDS:
------------

SPF: v=spf1 include:resend.com ~all
DKIM: 3 CNAME records from Resend
DMARC: v=DMARC1; p=none; ...

COMMON PATHS:
-------------

/api/auth/sign-up/email       # Sign up endpoint
/api/auth/reset-password      # Reset password endpoint
/api/auth/change-password     # Change password endpoint

================================================================================
                           CONCLUSION
================================================================================

This documentation provides a comprehensive guide for implementing email
verification, forgot password, and reset password functionality in your RMS
application. The system uses:

✅ Better Auth for authentication logic
✅ Resend for reliable email delivery
✅ Zod for type-safe validation
✅ Next.js for modern React components
✅ Security hooks for password validation

KEY TAKEAWAYS:
- Always validate passwords server-side
- Use verified custom domain for production
- Never reveal if email exists (security)
- Test all flows thoroughly
- Monitor email delivery rates
- Follow security best practices

The implementation is production-ready and follows industry best practices
for security, user experience, and code organization.

For questions or issues:
- Better Auth Docs: https://www.better-auth.com/docs
- Resend Docs: https://resend.com/docs
- Next.js Docs: https://nextjs.org/docs

================================================================================
                           END OF DOCUMENTATION
================================================================================

